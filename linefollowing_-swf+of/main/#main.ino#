#define enA_1 10
#define enA_2 11
#define in1_1 2
#define in2_1 4
#define in1_2 7
#define in2_2 8
#define servopin 12
#define trig1 3
#define trig2 6
#define echo1 5
#define echo2 9
#define leftir A0
#define midir A1
#define rightir A2

//sensor 1 side, sensor 2 front
#include <WiFiS3.h>
#include <Servo.h>
IPAddress AP_IP(192, 168, 4, 1);
IPAddress AP_GW(192, 168, 4, 1);
IPAddress AP_SN(255, 255, 255, 0);

enum MovState {
  FORWARD,
  ROTLEFT,
  ROTRIGHT
};

MovState prevState = FORWARD;
MovState currState = FORWARD;

Servo servo1;

const int num_positions = 9;
int servo_dir = 0;
int servo_step;

void direction176 () {
  drive(0, HIGH, HIGH, 0, 160, 160);
  delay(300);
  drive(0, HIGH, 0, HIGH, 133, 133);
  delay(200);
  stopDrive();
}

void direction156 () {
  drive(0, HIGH, HIGH, 0, 160, 160);
  delay(230);
  drive(0, HIGH, 0, HIGH, 133, 133);
  delay(200);
  stopDrive();
}

void direction132 () {
  drive(0, HIGH, HIGH, 0, 160, 160);
  delay(160);
  drive(0, HIGH, 0, HIGH, 133, 133);
  delay(200);
  stopDrive();
}

void direction110 () {
  drive(0, HIGH, HIGH, 0, 160, 160);
  delay(100);
  drive(0, HIGH, 0, HIGH, 133, 133);
  delay(200);
  stopDrive();
}

void direction88 () {
  drive(0, HIGH, 0, HIGH, 133, 133);
  delay(200);
  stopDrive();
}

void direction66 () {
  drive(HIGH, 0, 0, HIGH, 160, 160);
  delay(170);
  drive(0, HIGH, 0, HIGH, 133, 133);
  delay(200);
  stopDrive();
}

void direction44 () {
  drive(HIGH, 0, 0, HIGH, 160, 160);
  delay(220);
  drive(0, HIGH, 0, HIGH, 133, 133);
  delay(200);
  stopDrive();
}

void direction22 () {
  drive(HIGH, 0, 0, HIGH, 160, 160);
  delay(280);
  drive(0, HIGH, 0, HIGH, 133, 133);
  delay(200);
  stopDrive();
}

void direction0() {
  drive(HIGH, 0, 0, HIGH, 160, 160);
  delay(400);
  drive(0, HIGH, 0, HIGH, 133, 133);
  delay(200);
  stopDrive();
}

void goForward() {
  drive(0, HIGH, 0, HIGH, 110, 110);
}

void goBackward() {
  drive(HIGH, 0, HIGH, 0, 120, 120);
}

void strongLeftTurn() {
  drive(0, HIGH, HIGH, 0, 170, 170);
}

void strongRightTurn() {
  drive(HIGH, 0, 0, HIGH, 170, 170);
}

void leftRot() {
  drive(0, HIGH, HIGH, 0, 80, 80);
}

void rightRot() {
  drive(HIGH, 0, 0, HIGH, 80, 80);
}

void turnLeft(int speed) {
  drive(0, HIGH, 0, HIGH, 60, speed);
}
void turnRight(int speed) {
  drive(0, HIGH, 0, HIGH, speed, 60);
}
void stopDrive() {
  drive(0, 0, 0, 0, 0, 0);
}

int IRBufFilter(const int* buf) {
  int cnt = 0;
  for (int i = 0; i < 9; i++){
    if(buf[i] > 0) {
      cnt++;
    }
  }
  if(cnt >= 5) {
    return 1;
  } else {
    return 0;
  }
}

boolean autonomous_mode = 0;
boolean autonomous_mode_objectfollow = 0;
boolean autonomous_mode_linefollow = 0;

const char* ssid = "ARDUINO_FINAL_BOSS";  // open AP (no password)
WiFiServer server(80);

const int SERIAL_BAUD = 115200;

// Command bytes
const uint8_t CMD_W = 0b00000001;
const uint8_t CMD_A = 0b00000100;
const uint8_t CMD_S = 0b00000010;
const uint8_t CMD_D = 0b00000011;
const uint8_t CMD_STOP = 0b00000111;

const char page[] PROGMEM = 
"<!doctype html><html><head><meta charset=\"utf-8\"/>"
"<title>WASD Control</title>"
"<script>"
"const CMD={W:1,A:4,S:2,D:5,STOP:7,M:255,N:254,B:101,F:65,G:66,Q:128,E:129};"
"let pressed=new Set();"
"async function send(b){fetch('/api/cmd?b='+b).catch(()=>{});} "
"function down(k){if(!pressed.has(k)){pressed.add(k);send(CMD[k]);}} "
"function up(k){if(pressed.has(k)){pressed.delete(k);} if(pressed.size==0) send(CMD.STOP);} "
"window.addEventListener('keydown',e=>{const k=e.key.toUpperCase();if(CMD[k]){e.preventDefault();down(k);}});"
"window.addEventListener('keyup',e=>{const k=e.key.toUpperCase();if(CMD[k]){e.preventDefault();up(k);}});"
"</script></head><body>"
"<h1>WASD Controller</h1>"
"<p>Use keyboard W/A/S/D. Releases â†’ Stop. M Autonomous, N Object following</p>"
"</body></html>";

int speed = 255;
int lowVol = 0;

void printFloat9(const float a[9]) {
  for (int i = 0; i < 9; ++i) {
    if (i) Serial.print(", ");
    Serial.print(a[i], 6);  // change precision if you want
  }
  Serial.println();
}

void fineturnDirection(bool direction) { // 0 left 1 right
  stopDrive();
  delay(40);
  if (!direction) {
    leftRot();
    currState = ROTLEFT;
  } else {
    rightRot();
    currState = ROTRIGHT;
  }
  while (true) {
      int leftJudge = digitalRead(leftir);
      int midJudge = digitalRead(midir);
      int rightJudge = digitalRead(rightir);

      if (midJudge == 0 && leftJudge == 1 && rightJudge == 1) {
        // Before going forward, we want to check if we are really at the position
        stopDrive();
        int score = 0;
        for (int i = 0; i < 4; i++) {
          int v1 = digitalRead(leftir);
          int v2 = digitalRead(midir);
          int v3 = digitalRead(rightir);
          if (v1 == 1 && v2 == 0 && v3 == 1) {
            score++;
          } 
          delay(4);
        }
        if (score >= 3) {
          goForward();
          return;
        } else {
          if (currState == FORWARD) {
            goForward();
          } else if (currState == ROTLEFT) {
            leftRot();
          } else if (currState == ROTRIGHT) {
            rightRot();
          } 
          continue;
        }
      } else if (midJudge == 1 && leftJudge == 1 && rightJudge == 1) {
        // for now, continue the previous state
        continue;
      }
  }
}
void setup() {
  servo1.attach(servopin);
  servo_step = 180 / (num_positions - 1);

  servo1.write(0);
  delay(15);    
  Serial1.begin(SERIAL_BAUD);  // UART to robot
  if (WiFi.beginAP(ssid) != WL_AP_LISTENING) {
    Serial.println("AP start failed");
    while (true)
      ;
  }

  pinMode(trig1, OUTPUT);
  pinMode(echo1, INPUT);
  pinMode(trig2, OUTPUT);
  pinMode(echo2, INPUT);

  server.begin();
  pinMode(enA_1, OUTPUT);
  pinMode(enA_2, OUTPUT);
  pinMode(in1_1, OUTPUT);
  pinMode(in2_1, OUTPUT);
  pinMode(in1_2, OUTPUT);
  pinMode(in2_2, OUTPUT);
  pinMode(in1_2, OUTPUT);

  pinMode(13, OUTPUT);

  pinMode(leftir, INPUT);
  pinMode(midir, INPUT);
  pinMode(rightir, INPUT);
//  pinMode(encleft, INPUT_PULLUP);
  //pinMode(encright, INPUT_PULLUP);
  Serial.begin(115200);
}

void loop() {
  int tmp = digitalRead(midir);
  int tmp2 = digitalRead(leftir);
  int tmp3 = digitalRead(rightir);
  if (tmp == 0) {
    digitalWrite(13, HIGH);
  } else {
  digitalWrite(13, LOW);
  }
  Serial.print(tmp2);
  Serial.print(" ");
  Serial.print(tmp);
  Serial.print(" ");
  Serial.print(tmp3);
  Serial.println();
  if (autonomous_mode_linefollow) {
    int leftVal = digitalRead(leftir);
    int midVal = digitalRead(midir);
    int rightVal = digitalRead(rightir);

      int leftJudge = leftVal;
      int midJudge = midVal;
      int rightJudge = rightVal;

      if (leftJudge == 1 && rightJudge == 1 && midJudge == 0) {
        prevState = currState;
        currState = FORWARD;
        goForward();
      } else if (leftJudge == 0 && rightJudge == 1) {
        prevState = currState;
        fineturnDirection(0);
      } else if (leftJudge == 1 && rightJudge == 0) {
        prevState = currState;
        fineturnDirection(1);
      } else if (leftJudge == 1 && rightJudge == 1 && midJudge == 1){
        // Out of line, recover from prevState;
        stopDrive();
        delay(10);
        if (prevState == FORWARD) {
          leftRot();
          delay(20); // For now, we want to try to rotate and fine our way back
          //todo: lost line transition check logic
        } else if (prevState == ROTLEFT) {
          rightRot();
          delay(30);
        } else if (prevState == ROTRIGHT) {
          leftRot();
          delay(20);
        }
      } else {
        // unknown cornercase
        if (currState == FORWARD) {
          delay(10);
          goForward();
        } else if (currState == ROTLEFT) {
          delay(10);
          rightRot();
        } else if (currState == ROTRIGHT) {
          delay(10);
          leftRot();
        }
        goForward();
        delay(5);
      }
  }
  if (Serial.available()) {
    char command = Serial.read();
    if (command == 0b00000001) {
      // FORWARD FORWARD
      drive(lowVol, HIGH, lowVol, HIGH, speed, speed);
    } else if (command == 0b00000010) {
      // BACKWARD BACKWARD
      drive(HIGH, lowVol, HIGH, lowVol, speed, speed);
    } else if (command == 0b00000011) {
      // FORWARD STATIC
      drive(lowVol, HIGH, HIGH, HIGH, speed, speed);
    } else if (command == 0b00000100) {
      // STATIC FORWARD
      drive(HIGH, HIGH, lowVol, HIGH, speed, speed);
    } else if (command == 0b00000101) {
      // BACKWARD STATIC
      drive(HIGH, lowVol, HIGH, HIGH, speed, speed);
    } else if (command == 0b00000110) {
      // STATIC BACKWARD
      drive(HIGH, HIGH, HIGH, lowVol, speed, speed);
    } else if (command == 0b00000111) {
      // STATIC STATIC
      drive(HIGH, HIGH, HIGH, HIGH, speed, speed);
      digitalWrite(enA_1, HIGH);
      digitalWrite(enA_2, HIGH);
    } else if (command == 0b01000000) {
      // FORWARD BACKWARD
      drive(HIGH, speed, speed, HIGH, speed, speed);
    } else if (command == 0b01100000) {
      // BACKWARD FORWARD
      drive(speed, HIGH, HIGH, speed, speed, speed);
    } else if (command == 0b01110000) {
      //speed control init
      while (!Serial.available()) {}  // Wait for speed control signal
      char speedVal = Serial.read();
      speed = speedVal;
      Serial.print(speed);
    } else if (command == 0b01111111) {
      autonomous_mode = 1;
    }
  }

  WiFiClient client = server.available();
  if (!client) return;

  // Wait for request
  String req = client.readStringUntil('\r');
  client.readStringUntil('\n');  // discard

  if (req.startsWith("GET /api/cmd")) {
    int bIndex = req.indexOf("b=");
    if (bIndex > 0) {
      int val = req.substring(bIndex + 2).toInt();
      if (val >= 0 && val <= 255) {
        switch (val) {
          case 1:
            drive(lowVol, HIGH, lowVol, HIGH, speed, speed);
            break;
          case 4:
            drive(lowVol, HIGH, lowVol, lowVol, speed, speed);
            break;
          case 2:
            drive(HIGH, lowVol, HIGH, lowVol, speed, speed);
            break;
          case 5:
            drive(lowVol, lowVol, lowVol, HIGH, speed, speed);
            break;
          case 254:
            autonomous_mode_objectfollow = !autonomous_mode_objectfollow;
            break;
          case 255:
            autonomous_mode = !autonomous_mode;
            drive(lowVol, lowVol, lowVol, lowVol, speed, speed);
            break;
          case 65:
            servo_dir -= servo_step;
            servo1.write(servo_dir);
            Serial.print(servo_dir);
            delay(100);
            break; 
          case 66:
            servo_dir += servo_step;
            servo1.write(servo_dir);
            Serial.print(servo_dir);
            delay(100); 
            break;
          case 128:
            leftRot();
            break;
          case 129:
            rightRot();
            break;  
          case 101:
            autonomous_mode_linefollow = !autonomous_mode_linefollow;
            drive(lowVol, lowVol, lowVol, lowVol, speed, speed);
            break;
          default:
            drive(lowVol, lowVol, lowVol, lowVol, speed, speed);
        }
      }
    }
    client.println("HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\nOK");
  } else {  // root page
    client.println("HTTP/1.1 200 OK");
    client.println("Content-Type: text/html");
    client.println("Connection: close\r\n");
    client.print(page);
  }
  client.stop();
}

void drive(int p1, int p2, int p3, int p4, int power1, int power2) {
  analogWrite(enA_1, power1);
  analogWrite(enA_2, power2);

  digitalWrite(in1_1, p3);
  digitalWrite(in2_1, p4);

  digitalWrite(in1_2, p1);
  digitalWrite(in2_2, p2);
}

float read_ultrasonic(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);   // start low to ensure no pulse is sent
  delayMicroseconds(5);         // ensure 5 microseconds of no signal to avoid interference
  digitalWrite(trigPin, HIGH);  // start pulse high
  delayMicroseconds(10);        // continue for 10 microseconds
  digitalWrite(trigPin, LOW);   // stop pulse

  // Measure length of time before pulse comes in
  float duration = pulseIn(echoPin, HIGH);

  // Convert the time into a distance
  float cm = (duration / 2) / 29.1;  // Divide by 29.1 or multiply by 0.0343

  return cm;
}